#include QMK_KEYBOARD_H
#if __has_include("keymap.h")
#    include "keymap.h"
#endif


/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */
// const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
//     [0] = LAYOUT_split_3x5_3(KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_Q, KC_L, KC_SCLN, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_LGUI, KC_SPC, MO(1), MO(2), KC_ENT, KC_RALT),
//     [1] = LAYOUT_split_3x5_3(KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_LEFT, KC_DOWN, KC_UP, KC_RGHT, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_LGUI, KC_SPC, KC_TRNS, MO(3), KC_ENT, KC_RALT),
//     [2] = LAYOUT_split_3x5_3(KC_EXLM, KC_AT, KC_HASH, KC_DLR, KC_PERC, KC_CIRC, KC_AMPR, KC_ASTR, KC_LPRN, KC_RPRN, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_MINS, KC_EQL, KC_LBRC, KC_RBRC, KC_BSLS, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_UNDS, KC_PLUS, KC_LCBR, KC_RCBR, KC_PIPE, KC_LGUI, KC_SPC, MO(3), KC_TRNS, KC_ENT, KC_RALT),
//     [3] = LAYOUT_split_3x5_3(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, RGB_HUI, RGB_SAI, RGB_VAI, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, RGB_HUD, RGB_SAD, RGB_VAD, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_LGUI, KC_SPC, KC_TRNS, KC_TRNS, KC_ENT, KC_RALT)
// };

#include "custom_keycodes.h"
#include "process_tap_dance.h"

typedef struct {
  bool is_press_action;
  int state;
} tap;

enum {
  SINGLE_TAP = 1,
  SINGLE_HOLD = 2,
  DOUBLE_TAP = 3,
  DOUBLE_HOLD = 4,
  DOUBLE_SINGLE_TAP = 5, //send two single taps
  TRIPLE_TAP = 6,
  TRIPLE_HOLD = 7
};

//Tap dance enums
enum {
  TD_COPY,
  TD_PASTE,
  TD_TAB_CLOSE_REOPEN
};

int cur_dance (tap_dance_state_t *state);

// declarations for tap dance. Put them here so it can be used in any keymap
void copy_finished(tap_dance_state_t *state, void *user_data);

enum cheapino_keymap_layers {
    L_BASE = 0,
    L_SHIFT,
    L_FUNCTION,
    L_ARROWS,
    L_SYMBOLS,
    L_NUMPAD,
    L_VSCODE,
    L_WINDOWS,
    L_MEDIA,
};

#define KC_Y_MEDIA LT(L_MEDIA, KC_Y)
#define KC_J_VSCODE LT(L_VSCODE, KC_J)
#define KC_ENT_FUNCTION LT(L_FUNCTION, KC_ENT)
#define KC_BSPC_SHIFT LT(L_SHIFT, KC_BSPC)
#define KC_TAB_ARROWS LT(L_ARROWS, KC_TAB)
#define KC_DEL_NUMPAD LT(L_NUMPAD, KC_DEL)
#define KC_SPC_SYMBOLS LT(L_SYMBOLS, KC_SPC)

// clang-format off

// -----------------------------------------------------------------------------------------
// |   q   |  h  |  o  |  u  |  x  | /**/ |  g  |  c  |  r  |  f  |  z  |
// |  y/-  |  i  |  e  |  a  |  .  | /**/ |  d  |  s  |  t  |  n  | b/; |
// |   j   |  /  |  ,  |  k  |  '  | /**/ |  w  |  m  |  l  |  p  |  v  |
//       | ENTER | BACKSPACE | TAB | /**/ | DELETE | SPACE |
#define LAYER_BASE \
KC_Q,         KC_H,     KC_O,               KC_U,           KC_X,           /**/  KC_G,           KC_C,           KC_R,   KC_F,   KC_Z,           \
KC_Y_MEDIA,   KC_I,     KC_E,               KC_A,           KC_DOT,         /**/  KC_D,           KC_S,           KC_T,   KC_N,   KC_B, \
KC_J_VSCODE,  KC_SLSH,  KC_COMM,            KC_K,           KC_QUOT,        /**/  KC_W,           KC_M,           KC_L,   KC_P,   KC_V, \
                        KC_ENT_FUNCTION,    KC_BSPC_SHIFT,  KC_TAB_ARROWS,  /**/  KC_DEL_NUMPAD,  KC_SPC_SYMBOLS, _______

// -----------------------------------------------------------------------------------------
// |  Q  |  H  |  O  |  U  |  X  | /**/ |  G  |  C  |  R  |  F  |  Z  |
// |  Y  |  I  |  E  |  A  |  @  | /**/ |  D  |  S  |  T  |  N  |  B  |
// |  J  |  ?  |  !  |  K  |  `  | /**/ |  W  |  M  |  L  |  P  |  V  |
//             |     |  *  |     | /**/ |     | LOCK |
#define LAYER_SHIFT \
LSFT(KC_Q), LSFT(KC_H), LSFT(KC_O), LSFT(KC_U), LSFT(KC_X),       LSFT(KC_G), LSFT(KC_C), LSFT(KC_R), LSFT(KC_F), LSFT(KC_Z), \
LSFT(KC_Y), LSFT(KC_I), LSFT(KC_E), LSFT(KC_A), KC_AT,            LSFT(KC_D), LSFT(KC_S), LSFT(KC_T), LSFT(KC_N), LSFT(KC_B), \
LSFT(KC_J), KC_QUES,    KC_EXLM,    LSFT(KC_K), KC_GRV,           LSFT(KC_W), LSFT(KC_M), LSFT(KC_L), LSFT(KC_P), LSFT(KC_V), \
                        _______,    _______,    _______,          _______,    QK_LOCK,    _______

// -----------------------------------------------------------------------------------------
// | ESC           |      | CLOSE TAB        | NEW TAB | SAVE | /**/ | F10 | F7 | F8 | F9 |    |
// | LINE COMMENT  | UNDO | COPY             | PASTE   | REDO | /**/ | F11 |    | F1 | F2 | F3 |
// | BLOCK COMMENT | FIND | FIND IN SOLUTION |         |      | /**/ | F12 | F4 | F5 | F6 |    |
//                        |        *         |         |      | /**/ |     |    |
#define LAYER_FUNCTION \
KC_ESC,            _______,     TD(TD_TAB_CLOSE_REOPEN),  LCTL(KC_T),   LCTL(KC_S),       /**/ KC_F10,     KC_F7,    KC_F8,    KC_F9,  _______,  \
LCTL(KC_SLSH),     LCTL(KC_Z),  TD(TD_COPY),              TD(TD_PASTE), LCTL(LSFT(KC_Z)), /**/ KC_F11,     _______,  KC_F1,    KC_F2,  KC_F3,    \
LALT(LSFT(KC_A)),  LCTL(KC_F),  LCTL(LSFT(KC_F)),         _______,      _______,          /**/ KC_F12,     KC_F4,    KC_F5,    KC_F6,  _______,  \
                                _______,                  _______,      _______,          /**/ _______,    _______,  _______

// -----------------------------------------------------------------------------------------
// | RESET      |                | SELECT WORD |         |          | /**/ |    | HOME    | UP   | END       |        |
// | SCREENSHOT | SHIFT          | CTRL        | ALT     |          | /**/ |    | LEFT    | DOWN | RIGHT     | INSERT |
// | RESTART    | DEBUG/CONTINUE | STEP        | STEP IN | STEP OUT | /**/ |    | PAGE UP |      | PAGE DOWN |        |
//                               |             | BOOT    |     *    | /**/ |    |         |
#define LAYER_ARROWS \
QK_RBT,             _______,    SELECT_WORD,    _______,    _______,        /**/ _______,  KC_HOME,    KC_UP,      KC_END,         _______, \
LGUI(LSFT(KC_S)),   KC_LSFT,    KC_LCTL,        KC_LALT,    _______,        /**/ _______,  KC_LEFT,    KC_DOWN,    KC_RIGHT,       KC_INSERT, \
LSFT(LCTL(KC_F5)),  KC_F5,      KC_F10,         KC_F11,     LSFT(KC_F11),   /**/ _______,  KC_PAGE_UP, _______,    KC_PAGE_DOWN,   _______, \
                                _______,        QK_BOOT,    _______,        /**/ _______,  _______,    _______

// -----------------------------------------------------------------------------------------
// |     |  <  |  $  |  >  |     | /**/ |     |  [  |  _  |  ]  |     |
// |  \  |  (  |  "  |  )  |  #  | /**/ |  %  |  {  |  =  |  }  |  |  |
// |     |  :  |  *  |  +  |     | /**/ |     |  &  |  ^  |  ~  |     |
//             |     |     |     | /**/ |     |  *  |
#define LAYER_SYMBOLS \
_______,    KC_LT,      KC_DLR,     KC_GT,      _______, /**/ _______,  KC_LBRC,    KC_UNDS,    KC_RBRC,    _______, \
KC_SLSH,    KC_LPRN,    KC_DQT,     KC_RPRN,    KC_HASH, /**/ KC_PERC,  KC_LCBR,    KC_EQUAL,   KC_RCBR,    KC_PIPE, \
_______,    KC_COLN,    KC_ASTR,    KC_PLUS,    _______, /**/ _______,  KC_AMPR,    KC_CIRC,    KC_TILDE,   _______, \
                        _______,    _______,    _______, /**/ _______,  _______,    _______

// -----------------------------------------------------------------------------------------
// |    | (  | +  | )  |    | /**/ | PERIOD    |  7  |  8  |  9  | RESET |
// | =  | /  | -  | *  | .  | /**/ | BACKSPACE |  0  |  1  |  2  |  3    |
// |    | :  |    |    |    | /**/ | COLON     |  4  |  5  |  6  |       |
//           |    |    |    | /**/ |      *    | BOOT|
#define LAYER_NUMPAD \
_______,    KC_LPRN,    KC_PLUS,    KC_RPRN,    _______, /**/ KC_DOT,   KC_7,    KC_8,    KC_9,    QK_RBT,  \
KC_EQL,     KC_SLSH,    KC_MINS,    KC_ASTR,    KC_DOT,  /**/ KC_BSPC,  KC_0,    KC_1,    KC_2,    KC_3,    \
_______,    KC_COLN,    _______,    _______,    _______, /**/ KC_COLN,  KC_4,    KC_5,    KC_6,    _______, \
                        _______,    _______,    _______, /**/ _______,  QK_BOOT, _______

// -----------------------------------------------------------------------------------------
// |     |               |            |                 |    | /**/ |    |    |    |    |    |
// |     | back          | def        | forward         |    | /**/ |    |    |    |    |    |
// |  *  | prev bookmark | bookmark   | next bookmark   |    | /**/ |    |    |    |    |    |
//                       |            |                 |    | /**/ |    |    |
#define LAYER_VSCODE \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
                        _______,    _______,    _______, /**/ _______,  _______,    _______

// -----------------------------------------------------------------------------------------
// |     |VD left           |window up      |VD right       |new VD         | /**/ |    |    | BRIGHTNESS UP    |    |    |
// |  *  |window left       |window down    |window right   |exit VD        | /**/ |    |    | BRIGHTNESS DOWN  |    |    |
// |     |                  |               |               |               | /**/ |    |    |                  |    |    |
//                          |monitor left   |task view      |monitor right  | /**/ |    |    |
#define LAYER_WINDOWS \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
                        _______,    _______,    _______, /**/ _______,  _______,    _______

// -----------------------------------------------------------------------------------------
// |   *   | VOL DOWN / PREV | VOL UP / NEXT | PLAY PAUSE / MUTE |    | /**/ |    |    |    |    |    |
// |       |                 |               |                   |    | /**/ |    |    |    |    |    |
// |       |                 |               |                   |    | /**/ |    |    |    |    |    |
//                           |               |                   |    | /**/ |    |    |
#define LAYER_MEDIA \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
                        _______,    _______,    _______, /**/ _______,  _______,    _______

// -----------------------------------------------------------------------------------------
// |    |    |    |    |    | /**/ |    |    |    |    |    |
// |    |    |    |    |    | /**/ |    |    |    |    |    |
// |    |    |    |    |    | /**/ |    |    |    |    |    |
//           |    |    |    | /**/ |    |    |
#define LAYER_TEMPLATE \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
_______,    _______,    _______,    _______,    _______, /**/ _______,  _______,    _______,    _______,    _______, \
                        _______,    _______,    _______, /**/ _______,  _______,    _______


/**
 * \brief Add Home Row mod to a layout.
 *
 * Expects a 10-key per row layout.  Adds support for GACS (Gui, Alt, Ctl, Shift)
 * home row.  The layout passed in parameter must contain at least 20 keycodes.
 *
 * This is meant to be used with `LAYER_ALPHAS_QWERTY` defined above, eg.:
 *
 *     HOME_ROW_MOD_GACS(LAYER_ALPHAS_QWERTY)
 */
#define _HOME_ROW_MOD_GACS(                                            \
    L00, L01, L02, L03, L04, R05, R06, R07, R08, R09,                  \
    L10, L11, L12, L13, L14, R15, R16, R17, R18, R19,                  \
    ...)                                                               \
             L00,         L01,         L02,         L03,         L04,  \
             R05,         R06,         R07,         R08,         R09,  \
             L10, LSFT_T(L11), LCTL_T(L12), LALT_T(L13), LGUI_T(L14),  \
     RGUI_T(R15), RALT_T(R16), RCTL_T(R17), RSFT_T(R18),         R19,  \
      __VA_ARGS__
#define HOME_ROW_MOD_GACS(...) _HOME_ROW_MOD_GACS(__VA_ARGS__)

#define LAYOUT_wrapper(...) LAYOUT_split_3x5_3(__VA_ARGS__)

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
  [L_BASE] = LAYOUT_wrapper(HOME_ROW_MOD_GACS(LAYER_BASE)),
  [L_SHIFT] = LAYOUT_wrapper(LAYER_SHIFT),
  [L_FUNCTION] = LAYOUT_wrapper(LAYER_FUNCTION),
  [L_ARROWS] = LAYOUT_wrapper(LAYER_ARROWS),
  [L_SYMBOLS] = LAYOUT_wrapper(LAYER_SYMBOLS),
  [L_NUMPAD] = LAYOUT_wrapper(LAYER_NUMPAD),
  [L_VSCODE] = LAYOUT_wrapper(LAYER_VSCODE),
  [L_WINDOWS] = LAYOUT_wrapper(LAYER_WINDOWS),
  [L_MEDIA] = LAYOUT_wrapper(LAYER_MEDIA),
};


/* Return an integer that corresponds to what kind of tap dance should be executed.
 *
 * How to figure out tap dance state: interrupted and pressed.
 *
 * Interrupted: If the state of a dance dance is "interrupted", that means that another key has been hit
 *  under the tapping term. This is typically indicitive that you are trying to "tap" the key.
 *
 * Pressed: Whether or not the key is still being pressed. If this value is true, that means the tapping term
 *  has ended, but the key is still being pressed down. This generally means the key is being "held".
 *
 * One thing that is currenlty not possible with qmk software in regards to tap dance is to mimic the "permissive hold"
 *  feature. In general, advanced tap dances do not work well if they are used with commonly typed letters.
 *  For example "A". Tap dances are best used on non-letter keys that are not hit while typing letters.
 *
 * Good places to put an advanced tap dance:
 *  z,q,x,j,k,v,b, any function key, home/end, comma, semi-colon
 *
 * Criteria for "good placement" of a tap dance key:
 *  Not a key that is hit frequently in a sentence
 *  Not a key that is used frequently to double tap, for example 'tab' is often double tapped in a terminal, or
 *    in a web form. So 'tab' would be a poor choice for a tap dance.
 *  Letters used in common words as a double. For example 'p' in 'pepper'. If a tap dance function existed on the
 *    letter 'p', the word 'pepper' would be quite frustating to type.
 *
 * For the third point, there does exist the 'DOUBLE_SINGLE_TAP', however this is not fully tested
 *
 */
int cur_dance (tap_dance_state_t *state) {
  if (state->count == 1) {
    if (state->interrupted || !state->pressed)  return SINGLE_TAP;
    //key has not been interrupted, but they key is still held. Means you want to send a 'HOLD'.
    else return SINGLE_HOLD;
  }
  else if (state->count == 2) {
    /*
     * DOUBLE_SINGLE_TAP is to distinguish between typing "pepper", and actually wanting a double tap
     * action when hitting 'pp'. Suggested use case for this return value is when you want to send two
     * keystrokes of the key, and not the 'double tap' action/macro.
    */
    if (state->interrupted) return DOUBLE_SINGLE_TAP;
    else if (state->pressed) return DOUBLE_HOLD;
    else return DOUBLE_TAP;
  }
  //Assumes no one is trying to type the same letter three times (at least not quickly).
  //If your tap dance key is 'KC_W', and you want to type "www." quickly - then you will need to add
  //an exception here to return a 'TRIPLE_SINGLE_TAP', and define that enum just like 'DOUBLE_SINGLE_TAP'
  if (state->count == 3) {
    if (state->interrupted || !state->pressed)  return TRIPLE_TAP;
    else return TRIPLE_HOLD;
  }
  else return 8; //magic number. At some point this method will expand to work for more presses
}

//instanalize an instance of 'tap' for the 'x' tap dance.
static tap xtap_state = {
  .is_press_action = true,
  .state = 0
};

void copy_finished(tap_dance_state_t *state, void *user_data) {
    xtap_state.state = cur_dance(state);
    switch (xtap_state.state) {
        case SINGLE_TAP: tap_code16(LCTL(KC_C)); break;
        case SINGLE_HOLD: tap_code16(LCTL(KC_X)); break;
    }
}
// void copy_reset(tap_dance_state_t *state, void *user_data) {
//     switch (xtap_state.state) {
//         case SINGLE_TAP: unregister_code16(LCTL(KC_C)); break;
//         case SINGLE_HOLD: unregister_code16(LCTL(KC_X)); break;
//     }
//   xtap_state.state = 0;
// }

void paste_finished(tap_dance_state_t *state, void *user_data) {
    xtap_state.state = cur_dance(state);
    switch (xtap_state.state) {
        case SINGLE_TAP: tap_code16(LCTL(KC_V)); break;
        case SINGLE_HOLD: tap_code16(LGUI(KC_V)); break;
        case DOUBLE_HOLD: tap_code16(LCTL(LSFT(KC_V))); break;
        default: break;
    }
}

void tab_close_reopen_finished(tap_dance_state_t *state, void *user_data) {
    xtap_state.state = cur_dance(state);
    switch (xtap_state.state) {
        case SINGLE_TAP: tap_code16(LCTL(KC_W)); break;
        case SINGLE_HOLD: tap_code16(LCTL(LSFT(KC_T))); break;
        default: break;
    }
}

tap_dance_action_t tap_dance_actions[] = {
  [TD_COPY] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, copy_finished, NULL),
  [TD_PASTE] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, paste_finished, NULL),
  [TD_TAB_CLOSE_REOPEN] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, tab_close_reopen_finished, NULL)
};

// clang-format on

#if defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {

};
#endif // defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)